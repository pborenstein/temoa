<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Temoa</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- PWA Support -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Temoa">
    <link rel="apple-touch-icon" href="/icon-192.png">

    <style>
        /* ========================================
           GLOBAL STYLES
           ======================================== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #1a1a1a;
            line-height: 1.5;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        /* ========================================
           HEADER (shared between views)
           ======================================== */
        header {
            background: #1a1a1a;
            border-bottom: 1px solid #333333;
            padding: 12px 16px;
        }

        .header-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        h1 {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 6px;
            overflow: hidden;
        }

        .view-toggle-btn {
            padding: 6px 14px;
            font-size: 13px;
            font-weight: 500;
            background: transparent;
            color: #888888;
            border: none;
            cursor: pointer;
            transition: all 0.15s;
        }

        .view-toggle-btn:hover {
            background: #333333;
            color: #c0c0c0;
        }

        .view-toggle-btn.active {
            background: #4a6a8a;
            color: #ffffff;
        }

        .nav-link {
            color: #888888;
            text-decoration: none;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        /* Search controls row */
        .search-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .search-input-wrapper {
            flex: 1;
            position: relative;
        }

        /* Search history dropdown */
        .search-history-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 240px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .search-history-dropdown.visible {
            display: block;
        }

        .history-dropdown-item {
            padding: 10px 14px;
            font-size: 14px;
            color: #b0b0b0;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-dropdown-item:last-child {
            border-bottom: none;
        }

        .history-dropdown-item:hover,
        .history-dropdown-item.selected {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .history-dropdown-item .delete-btn {
            color: #666;
            font-size: 16px;
            padding: 0 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .history-dropdown-item:hover .delete-btn {
            opacity: 1;
        }

        .history-dropdown-item .delete-btn:hover {
            color: #cc4444;
        }

        .history-dropdown-empty {
            padding: 12px 14px;
            font-size: 13px;
            color: #666;
            text-align: center;
        }

        /* Adjust input border-radius when dropdown is visible */
        .search-input-wrapper:has(.search-history-dropdown.visible) .search-input {
            border-radius: 6px 6px 0 0;
        }

        .search-input {
            width: 100%;
            padding: 10px 14px;
            font-size: 16px;
            border: 1px solid #404040;
            border-radius: 6px;
            background: #2a2a2a;
            color: #e0e0e0;
            outline: none;
        }

        .search-input:focus {
            border-color: #666666;
        }

        .vault-select {
            padding: 10px 14px;
            font-size: 14px;
            border: 1px solid #404040;
            border-radius: 6px;
            background: #2a2a2a;
            color: #e0e0e0;
            outline: none;
            cursor: pointer;
            min-width: 140px;
        }

        .vault-select:focus {
            border-color: #666666;
        }

        .run-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            background: #4a6a8a;
            color: #ffffff;
            cursor: pointer;
            transition: background 0.15s;
            white-space: nowrap;
        }

        .run-btn:hover {
            background: #5a7a9a;
        }

        .run-btn:active {
            background: #3a5a7a;
        }

        .run-btn:disabled {
            background: #333333;
            color: #666666;
            cursor: not-allowed;
        }

        /* ========================================
           LIST VIEW MODE
           ======================================== */
        .list-view-container {
            display: none;
            height: calc(100vh - 110px);
            overflow: hidden;
        }

        .list-view-container.active {
            display: flex;
        }

        .list-main {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            max-width: 700px;
            margin: 0 auto;
            width: 100%;
        }

        .list-sidebar {
            width: 200px;
            background: #222222;
            border-left: 1px solid #333333;
            overflow-y: auto;
            padding: 16px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            font-weight: 500;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }


        /* ========================================
           EXPLORER VIEW MODE
           ======================================== */
        .explorer-view-container {
            display: none;
            height: calc(100vh - 110px);
            overflow: hidden;
        }

        .explorer-view-container.active {
            display: block;
        }

        .explorer-grid {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 16px;
            padding: 16px;
            height: 100%;
        }

        .pane {
            background: #222222;
            border: 1px solid #333333;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .pane-header {
            padding: 12px 16px;
            border-bottom: 1px solid #333333;
            font-size: 14px;
            font-weight: 500;
            color: #aaaaaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-btn {
            background: #3a3a3a;
            color: #888888;
            border: 1px solid #4a4a4a;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .help-btn:hover {
            background: #4a6a8a;
            color: #ffffff;
            border-color: #5a7a9a;
        }

        .help-panel {
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            border-radius: 8px;
            padding: 16px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .help-panel h2 {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333333;
        }

        .help-panel h3 {
            font-size: 13px;
            font-weight: 600;
            color: #cccccc;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .help-panel p {
            font-size: 12px;
            color: #b0b0b0;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .help-panel ul {
            font-size: 12px;
            color: #b0b0b0;
            line-height: 1.6;
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .help-panel code {
            background: #2a2a2a;
            color: #88aa88;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
        }

        .help-panel .score-example {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
            font-size: 11px;
            color: #aaaaaa;
        }

        .pane-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Scrollbar styles */
        .pane-content::-webkit-scrollbar,
        .list-main::-webkit-scrollbar,
        .list-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .pane-content::-webkit-scrollbar-track,
        .list-main::-webkit-scrollbar-track,
        .list-sidebar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .pane-content::-webkit-scrollbar-thumb,
        .list-main::-webkit-scrollbar-thumb,
        .list-sidebar::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        .pane-content::-webkit-scrollbar-thumb:hover,
        .list-main::-webkit-scrollbar-thumb:hover,
        .list-sidebar::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        /* Empty states */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666666;
            text-align: center;
            padding: 32px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 14px;
            line-height: 1.6;
        }

        /* ========================================
           EXPLORER CONTROLS (MIXER)
           ======================================== */
        .mixer-section {
            background: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .mixer-section h3 {
            font-size: 12px;
            font-weight: 500;
            color: #aaaaaa;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mixer-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .mixer-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .mixer-item label {
            font-size: 11px;
            color: #888888;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mixer-item input[type="number"] {
            padding: 6px 8px;
            font-size: 13px;
            border: 1px solid #404040;
            border-radius: 6px;
            background: #2a2a2a;
            color: #e0e0e0;
            outline: none;
            width: 100%;
        }

        .mixer-item input[type="number"]:focus {
            border-color: #666666;
        }

        /* Balance slider */
        .balance-slider {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .balance-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: #888888;
        }

        .balance-labels > span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .balance-value {
            font-size: 9px;
            color: #666666;
        }

        .balance-track {
            position: relative;
            height: 6px;
            background: linear-gradient(to right, #4a6a8a, #8a6a4a);
            border-radius: 3px;
        }

        .balance-input {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 100%;
            height: 18px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            margin: 0;
        }

        .balance-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            border: 2px solid #1a1a1a;
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        .balance-input::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            border: 2px solid #1a1a1a;
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        /* Checkbox items */
        .checkbox-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 12px;
            color: #c0c0c0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Tooltips */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #3a3a3a;
            color: #888888;
            font-size: 9px;
            font-weight: 600;
            cursor: help;
            flex-shrink: 0;
        }

        .tooltip-wrapper {
            position: relative;
            display: inline-flex;
        }

        .tooltip {
            position: fixed;
            background: #333333;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            color: #d0d0d0;
            white-space: normal;
            width: 240px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            line-height: 1.5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            text-transform: none;
            text-align: left;
            pointer-events: none;
        }

        /* Position tooltip dynamically via JS, but default fallback */
        .tooltip-wrapper:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }

        .tooltip strong {
            color: #ffffff;
            font-weight: 600;
        }

        .tooltip em {
            color: #aaaaaa;
            font-style: italic;
        }

        .tooltip-wrapper:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Fetch dirty indicator */
        .server-section {
            border-color: #333333;
        }

        .server-section.dirty {
            border-color: #665500;
        }

        .refetch-notice {
            display: none;
            font-size: 11px;
            color: #cc8800;
            margin-top: 10px;
            padding: 6px 10px;
            background: rgba(204, 136, 0, 0.1);
            border-radius: 4px;
        }

        .server-section.dirty .refetch-notice {
            display: block;
        }

        /* Filter components */
        .filter-input-wrapper {
            position: relative;
            margin-bottom: 8px;
        }

        .filter-input {
            width: 100%;
            padding: 8px 32px 8px 8px;
            font-size: 12px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            border: 1px solid #404040;
            border-radius: 6px;
            background: #2a2a2a;
            color: #e0e0e0;
            outline: none;
            resize: vertical;
            min-height: 60px;
            line-height: 1.4;
        }

        .filter-input:focus {
            border-color: #666666;
        }

        .filter-input::placeholder {
            color: #555555;
            font-size: 11px;
        }

        .filter-help-toggle {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border: 1px solid #404040;
            border-radius: 50%;
            background: #1a1a1a;
            color: #888888;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .filter-help-toggle:hover {
            background: #2a2a2a;
            border-color: #666666;
            color: #aaaaaa;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
            min-height: 20px;
        }

        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            font-size: 11px;
            background: #2a5a8a;
            color: #e0e0e0;
            border-radius: 12px;
            cursor: default;
        }

        .filter-chip-remove {
            cursor: pointer;
            font-weight: bold;
            opacity: 0.7;
            transition: opacity 0.15s;
        }

        .filter-chip-remove:hover {
            opacity: 1;
        }

        .tag-match-mode {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .toggle-group {
            display: flex;
            gap: 0;
            border: 1px solid #404040;
            border-radius: 6px;
            overflow: hidden;
        }

        .toggle-btn {
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 500;
            border: none;
            background: #2a2a2a;
            color: #888888;
            cursor: pointer;
            transition: all 0.15s;
        }

        .toggle-btn:not(:last-child) {
            border-right: 1px solid #404040;
        }

        .toggle-btn:hover {
            background: #333333;
            color: #aaaaaa;
        }

        .toggle-btn.active {
            background: #3a5a7a;
            color: #e0e0e0;
        }

        .filter-help {
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 6px;
            margin-top: 8px;
        }

        .filter-help h4 {
            font-size: 11px;
            font-weight: 500;
            color: #aaaaaa;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .filter-examples {
            font-size: 11px;
            line-height: 1.8;
            color: #c0c0c0;
        }

        .filter-examples code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            color: #6aa6d6;
        }

        /* Action buttons */
        .action-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 12px;
        }

        .action-btn {
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #404040;
            border-radius: 6px;
            background: #2a2a2a;
            color: #c0c0c0;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .action-btn:hover {
            background: #333333;
            border-color: #4a4a4a;
        }

        .action-btn:active {
            background: #1a1a1a;
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px;
            color: #888888;
            font-size: 14px;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333333;
            border-top-color: #888888;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ========================================
           RESULT CARDS
           ======================================== */
        .results-table {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .result-row {
            background: #1a1a1a;
            padding: 12px 14px;
            border-radius: 6px;
            border: 1px solid #333333;
            transition: all 0.2s;
            cursor: pointer;
        }

        .result-row:hover {
            background: #252525;
            border-color: #404040;
        }

        .result-row.selected {
            border-color: #4a6a8a;
            background: #1a2a3a;
        }

        .result-title-link {
            font-weight: 600;
            color: #c0c0c0;
            text-decoration: none;
            font-size: 14px;
            line-height: 1.3;
            display: block;
            margin-bottom: 4px;
        }

        .result-title-link:hover {
            color: #e0e0e0;
            text-decoration: underline;
        }

        .result-path {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #666666;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .result-dates {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #666666;
            font-size: 10px;
            margin-bottom: 6px;
        }

        .result-description {
            color: #999999;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 6px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 6px;
        }

        .tag {
            background: #2a2a2a;
            color: #888888;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            border: 1px solid #333333;
        }

        .result-scores-compact {
            font-size: 9px;
            color: #555555;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .type-badge,
        .project-badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            background: #2a2a2a;
            color: #888888;
            border: 1px solid #333333;
            text-decoration: none;
            white-space: nowrap;
        }

        .type-badge {
            background: #2a3a2a;
            color: #88aa88;
            border-color: #3a4a3a;
        }

        .project-badge {
            background: #2a2a3a;
            color: #8888aa;
            border-color: #3a3a4a;
        }

        .project-badge:hover {
            background: #3a3a4a;
            color: #aaaacc;
        }

        /* ========================================
           INSPECTOR PANE
           ======================================== */
        .inspector-section {
            background: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .inspector-section h3 {
            font-size: 11px;
            font-weight: 600;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .inspector-title {
            font-size: 14px;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .inspector-path {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 10px;
            color: #666666;
            margin-bottom: 10px;
        }

        .inspector-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 4px 0;
            font-size: 11px;
            border-bottom: 1px solid #252525;
        }

        .inspector-row:last-child {
            border-bottom: none;
        }

        .inspector-label {
            color: #777777;
            flex-shrink: 0;
            margin-right: 8px;
            min-width: 80px;
        }

        .inspector-value {
            color: #b0b0b0;
            text-align: right;
            word-break: break-word;
        }

        .inspector-value.mono {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 10px;
        }

        .inspector-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .inspector-tag {
            background: #2a2a2a;
            color: #888888;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            border: 1px solid #333333;
        }

        .score-bar {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .score-value {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            color: #c0c0c0;
            min-width: 50px;
            text-align: right;
        }

        .score-visual {
            flex: 1;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6a8a, #6a8aaa);
            transition: width 0.3s ease;
        }

        .inspector-link {
            display: inline-block;
            color: #6a8aaa;
            text-decoration: none;
            font-size: 11px;
            padding: 4px 8px;
            border: 1px solid #3a4a5a;
            border-radius: 4px;
            margin-top: 8px;
            transition: all 0.2s;
        }

        .inspector-link:hover {
            background: #2a3a4a;
            border-color: #4a6a8a;
            color: #8aaacc;
        }

        .close-inspector {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a2a;
            border: 1px solid #333333;
            border-radius: 4px;
            color: #888888;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s;
        }

        .close-inspector:hover {
            background: #333333;
            color: #c0c0c0;
        }

        /* ========================================
           MOBILE RESPONSIVE
           ======================================== */
        @media (max-width: 1024px) {
            .explorer-grid {
                grid-template-columns: 240px 1fr 280px;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 12px;
            }

            .header-top {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .search-controls {
                flex-direction: column;
                gap: 8px;
            }

            .vault-select {
                width: 100%;
            }

            .list-view-container {
                height: calc(100vh - 200px);
            }

            .explorer-view-container {
                height: calc(100vh - 200px);
            }

            .explorer-grid {
                grid-template-columns: 1fr;
                padding: 12px;
                gap: 12px;
            }

            .pane {
                min-height: 300px;
            }

            /* Mobile: Controls accordion (collapsed by default) */
            #controls-pane {
                max-height: 48px;
                transition: max-height 0.3s ease;
            }

            #controls-pane.expanded {
                max-height: 600px;
            }

            .pane-header {
                cursor: pointer;
                user-select: none;
            }

            .pane-header::after {
                content: '‚ñº';
                float: right;
                font-size: 12px;
                transition: transform 0.3s;
            }

            #controls-pane.expanded .pane-header::after {
                transform: rotate(180deg);
            }

            /* Mobile: Inspector as drawer */
            #inspector-pane {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 70vh;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 100;
                border-radius: 12px 12px 0 0;
            }

            #inspector-pane.visible {
                transform: translateY(0);
            }

            .close-inspector {
                display: flex;
            }
        }

        @media (min-width: 769px) {
            .close-inspector {
                display: none;
            }
        }

    </style>
</head>
<body>
    <header>
        <div class="header-top">
            <h1>Temoa</h1>
            <div class="header-right">
                <!-- View Toggle -->
                <div class="view-toggle">
                    <button class="view-toggle-btn active" data-view="list">List</button>
                    <button class="view-toggle-btn" data-view="explorer">Explorer</button>
                </div>
                <a href="/manage" class="nav-link">Manage</a>
            </div>
        </div>
        <div class="search-controls">
            <div class="search-input-wrapper">
                <input type="text" id="query-input" class="search-input" placeholder="Search your vault..." autocomplete="off">
                <div class="search-history-dropdown" id="history-dropdown"></div>
            </div>
            <select id="vault-select" class="vault-select">
                <option value="">Loading vaults...</option>
            </select>
            <button id="run-btn" class="run-btn">Run</button>
        </div>
    </header>

    <!-- LIST VIEW -->
    <div class="list-view-container active">
        <div class="list-main">
            <div class="empty-state">
                <div class="empty-state-icon">üîç</div>
                <div class="empty-state-text">
                    Enter a query and click Run<br>to see results
                </div>
            </div>
        </div>
    </div>

    <!-- EXPLORER VIEW -->
    <div class="explorer-view-container">
        <div class="explorer-grid">
            <!-- Controls Pane -->
            <div id="controls-pane" class="pane">
                <div class="pane-header">Controls</div>
                <div class="pane-content">
                    <!-- Fetch params (server round-trip required) -->
                    <div class="mixer-section server-section" id="fetch-section">
                        <h3>
                            Fetch
                            <span class="tooltip-wrapper">
                                <span class="info-icon">?</span>
                                <span class="tooltip">Controls WHICH documents are retrieved. Changes require clicking Run.</span>
                            </span>
                        </h3>

                        <!-- Hybrid balance slider -->
                        <div class="balance-slider" style="margin-bottom: 10px;">
                            <div class="balance-labels">
                                <span>
                                    Sem
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Fetch mode: Semantic</strong><br>Retrieves docs by conceptual similarity.<br>Good for exploratory searches.</span>
                                    </span>
                                </span>
                                <span class="balance-value" id="fetch-balance-value">50/50</span>
                                <span>
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Fetch mode: Keyword</strong><br>Retrieves docs with exact word matches.<br>Good for specific terms, tags, names.</span>
                                    </span>
                                    BM25
                                </span>
                            </div>
                            <div class="balance-track">
                                <input type="range" id="fetch-hybrid" class="balance-input" min="0" max="100" value="50">
                            </div>
                        </div>

                        <div class="mixer-grid">
                            <div class="mixer-item">
                                <label>
                                    Result Limit
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip">Maximum number of results to return.</span>
                                    </span>
                                </label>
                                <input type="number" id="fetch-limit" value="20" step="5" min="5" max="100">
                            </div>
                        </div>

                        <div class="checkbox-grid" style="margin-top: 10px;">
                            <div class="checkbox-item">
                                <input type="checkbox" id="fetch-rerank" checked>
                                <label for="fetch-rerank">
                                    Cross-encoder
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Re-ranks with ms-marco model</strong><br>Processes query + document together for better precision.<br><br>20-30% improvement in top-5 accuracy.<br>Adds ~200ms latency.<br><br><em>Skipped for tag-boosted results.</em></span>
                                    </span>
                                </label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="fetch-expand">
                                <label for="fetch-expand">
                                    Expand query
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Adds related terms (TF-IDF)</strong><br>For queries &lt;3 words, extracts important terms from top results.<br><br>Helps disambiguate short queries.<br>Adds ~400ms latency.<br><br><em>Not recommended for person names.</em></span>
                                    </span>
                                </label>
                            </div>
                        </div>

                        <div class="refetch-notice">
                            Fetch parameters changed. Click "Run" to apply.
                        </div>
                    </div>

                    <!-- Filters section (client-side, instant) -->
                    <div class="mixer-section" id="filters-section">
                        <h3>
                            Results Filter
                            <span class="tooltip-wrapper">
                                <span class="info-icon">?</span>
                                <span class="tooltip">Filter results instantly using Obsidian-style syntax. No server call needed.</span>
                            </span>
                        </h3>

                        <!-- Filter syntax input -->
                        <div class="filter-input-wrapper">
                            <textarea
                                id="filter-input"
                                class="filter-input"
                                placeholder="tag:python path:Gleanings file:README"
                                rows="2"
                            ></textarea>
                            <button id="filter-help-toggle" class="filter-help-toggle" title="Show filter syntax help">?</button>
                        </div>

                        <!-- Active filter chips -->
                        <div id="filter-chips" class="filter-chips"></div>

                        <!-- Filter help panel (collapsible) -->
                        <div id="filter-help" class="filter-help" style="display: none;">
                            <h4>Filter Syntax (Obsidian-Compatible)</h4>

                            <h5 style="margin-top: 12px; font-size: 13px; color: #555;">Basic Filters</h5>
                            <div class="filter-examples">
                                <code>tag:python</code> - Has tag #python (results without this tag excluded)<br>
                                <code>path:Gleanings</code> - Path contains "Gleanings"<br>
                                <code>file:README</code> - Filename contains "README"<br>
                                <code>[type:gleaning]</code> - Property type is "gleaning"<br>
                                <code>[status:active]</code> - Property status is "active"
                            </div>

                            <h5 style="margin-top: 12px; font-size: 13px; color: #555;">Boolean Logic</h5>
                            <div class="filter-examples">
                                <code>tag:python OR tag:javascript</code> - Either tag<br>
                                <code>tag:ai path:research</code> - Both conditions (implicit AND)<br>
                                <code>-tag:draft</code> - Exclude results with tag "draft"<br>
                                <code>(tag:ai OR tag:ml) path:research</code> - Grouped OR with AND
                            </div>

                            <h5 style="margin-top: 12px; font-size: 13px; color: #555;">Examples</h5>
                            <div class="filter-examples">
                                <code>[type:writing] tag:poem</code> - Type is "writing" AND has tag "poem"<br>
                                <code>[type:gleaning] -[type:daily]</code> - Gleanings but not daily notes<br>
                                <code>tag:python -tag:wip</code> - Has python tag, excludes wip tag
                            </div>

                            <h5 style="margin-top: 12px; font-size: 13px; color: #555;">Quoted Values</h5>
                            <div class="filter-examples">
                                <code>path:"Daily notes/2022"</code> - Path with spaces
                            </div>

                            <h5 style="margin-top: 12px; font-size: 13px; color: #555;">Backward Compatibility</h5>
                            <div class="filter-examples">
                                <code>tag:python,javascript</code> - Comma = OR (legacy)
                            </div>

                            <p style="font-size: 11px; color: #888; margin-top: 12px;">
                                Filters use Obsidian search syntax. Space between filters means AND.
                            </p>
                        </div>
                    </div>

                    <!-- Live params (client-side, instant) -->
                    <div class="mixer-section" id="live-section">
                        <h3>
                            Live
                            <span class="tooltip-wrapper">
                                <span class="info-icon">?</span>
                                <span class="tooltip">Re-rank retrieved results instantly. No server call needed.</span>
                            </span>
                        </h3>

                        <!-- Semantic/BM25 balance slider -->
                        <div class="balance-slider" style="margin-bottom: 10px;">
                            <div class="balance-labels">
                                <span>
                                    Sem
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Semantic (AI embeddings)</strong><br>0% = Pure conceptual matching<br>Finds "related topics" even with different words.</span>
                                    </span>
                                </span>
                                <span class="balance-value" id="live-balance-value">50/50</span>
                                <span>
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>BM25 (keyword matching)</strong><br>100% = Pure exact matching<br>Finds documents with your exact words (includes tag boosting).</span>
                                    </span>
                                    BM25
                                </span>
                            </div>
                            <div class="balance-track">
                                <input type="range" id="live-balance" class="balance-input" min="0" max="100" value="50">
                            </div>
                        </div>

                        <div class="mixer-grid">
                            <div class="mixer-item">
                                <label>
                                    Tag Multiplier
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Amplifies tag-boosted results</strong><br>When a document's tags match your query, its Final score is multiplied by this.<br><br><strong>1.0:</strong> No extra boost<br><strong>5.0:</strong> 5x stronger (default)<br><strong>10.0:</strong> Maximum boost<br><br><em>Watch the ‚ö° Yes indicator!</em></span>
                                    </span>
                                </label>
                                <input type="number" id="live-tags" value="5.0" step="0.5" min="1" max="10">
                            </div>

                            <div class="mixer-item">
                                <label>
                                    Time Weight
                                    <span class="tooltip-wrapper">
                                        <span class="info-icon">?</span>
                                        <span class="tooltip"><strong>Boosts recent documents</strong><br>Recent docs get: Final √ó (1 + Time Weight √ó recency)<br><br><strong>0.0:</strong> No time boost<br><strong>1.0:</strong> Standard boost (default)<br><strong>2.0:</strong> Double the boost<br><br>Recency decays with 90-day half-life.</span>
                                    </span>
                                </label>
                                <input type="number" id="live-time" value="1.0" step="0.1" min="0" max="2">
                            </div>
                        </div>
                    </div>

                    <!-- Action buttons -->
                    <div class="action-row">
                        <button id="reset-mix-btn" class="action-btn">Reset Mix</button>
                        <button id="export-btn" class="action-btn">Export JSON</button>
                    </div>
                </div>
            </div>

            <!-- Results Pane -->
            <div id="results-pane" class="pane">
                <div class="pane-header">
                    Results
                    <span id="result-count" style="color: #666666; font-weight: normal; text-transform: none; margin-left: 8px;"></span>
                </div>
                <div class="pane-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <div class="empty-state-text">
                            Enter a query and click Run<br>to see results
                        </div>
                    </div>
                </div>
            </div>

            <!-- Inspector Pane -->
            <div id="inspector-pane" class="pane">
                <div class="pane-header">
                    Inspector
                    <button id="help-btn" class="help-btn" title="Show scoring help">?</button>
                </div>
                <div class="pane-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìã</div>
                        <div class="empty-state-text">
                            Select a result<br>to inspect details
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // State Management
        // ========================================

        const STORAGE_VERSION = 3;
        const STORAGE_KEY = `temoa_v${STORAGE_VERSION}_state`;

        const state = {
            // Search state
            query: '',
            vault: null,
            vaults: [],

            // Results
            rawResults: [],
            remixedResults: [],
            pipelineData: null,

            // UI state
            viewMode: 'list',  // 'list' | 'explorer'
            selectedResult: null,
            searchHistory: [],

            // Fetch params (require server round-trip)
            fetchParams: {
                hybrid_weight: 0.5,
                limit: 20,
                rerank: true,
                expand: false
            },

            // Live params (client-side remix)
            liveParams: {
                mix_balance: 0.5,
                tag_multiplier: 5.0,
                time_weight: 1.0
            },

            // Filter params (client-side filtering)
            filterParams: {
                filterText: '',
                ast: null,           // Parsed AST from filter syntax
                serverFilters: {     // Extracted server-side filters (type, status)
                    include_types: [],
                    exclude_types: [],
                    include_statuses: [],
                    exclude_statuses: []
                }
            },

            fetchParamsChanged: false,
            lastFetchParams: null
        };

        // ========================================
        // Help Panel
        // ========================================

        function showHelpPanel() {
            const inspectorContent = document.querySelector('#inspector-pane .pane-content');

            const helpPanel = document.createElement('div');
            helpPanel.className = 'help-panel';
            helpPanel.innerHTML = `
                <h2>Understanding Temoa Scores</h2>

                <h3>üìä Score Types</h3>
                <p><strong>Semantic (0.0-1.0)</strong>: Conceptual similarity using AI embeddings. Finds documents about the same topic even with different words.</p>
                <div class="score-example">
                    0.0-0.3 = Not relevant<br>
                    0.3-0.5 = Somewhat related<br>
                    0.5-0.7 = Relevant<br>
                    0.7-1.0 = Highly relevant
                </div>

                <p><strong>BM25 (0-30+)</strong>: Keyword matching score. Higher = more exact word matches. Tags get 2x weight + 5x boost when matched.</p>
                <div class="score-example">
                    0-5 = Weak match<br>
                    5-15 = Good match<br>
                    15+ = Excellent match (often tag-boosted)
                </div>

                <p><strong>RRF (0.0-0.05+)</strong>: Reciprocal Rank Fusion. Combines Semantic + BM25 rankings. Tag-boosted docs get 1.5-2.0x multiplier.</p>
                <div class="score-example">
                    Formula: sum(1 / (60 + rank))<br>
                    ‚Ä¢ Docs in both lists = highest<br>
                    ‚Ä¢ Tag matches = 1.5-2.0x boost<br>
                    ‚Ä¢ BM25-only = conservative boost
                </div>

                <p><strong>Cross-Enc (-12 to +12)</strong>: Precision re-ranking using ms-marco model. Processes query + document together.</p>
                <div class="score-example">
                    Negative = Not relevant<br>
                    -1 to 0 = Weak match<br>
                    0 to +2 = Good match<br>
                    +2 to +12 = Excellent match
                </div>

                <p><strong>Final (0.0-2.0+)</strong>: Client-side remixed score using LIVE controls.</p>
                <div class="score-example">
                    Formula: (Sem √ó (1-balance) + BM25 √ó balance)<br>
                    ‚Ä¢ Tag-boosted: √ó Tag Multiplier<br>
                    ‚Ä¢ Recent docs: √ó (1 + Time Weight)
                </div>

                <h3>üéõÔ∏è How Controls Affect Results</h3>

                <p><strong>Sem/BM25 Balance (LIVE)</strong>:</p>
                <ul>
                    <li><code>0%</code> = Pure semantic (concept matching)</li>
                    <li><code>50%</code> = Balanced (default)</li>
                    <li><code>100%</code> = Pure BM25 (exact keywords + tags)</li>
                </ul>

                <p><strong>Tag Multiplier (LIVE)</strong>: When a document's tags match your query, its Final score is multiplied by this value. Look for the ‚ö° Yes indicator!</p>

                <p><strong>Time Weight (LIVE)</strong>: Recent documents get boosted. Uses 90-day half-life exponential decay. Higher weight = stronger boost for recent docs.</p>

                <h3>üîç Search Pipeline</h3>
                <p>Temoa uses a 7-stage pipeline:</p>
                <ul>
                    <li><strong>Stage 0:</strong> Query Expansion (optional, for short queries)</li>
                    <li><strong>Stage 1:</strong> Primary Retrieval (Semantic + BM25 hybrid)</li>
                    <li><strong>Stage 2:</strong> Chunk Deduplication (best chunk per file)</li>
                    <li><strong>Stage 3:</strong> Score Filtering (min threshold)</li>
                    <li><strong>Stage 4:</strong> Status Filtering (remove inactive)</li>
                    <li><strong>Stage 5:</strong> Type Filtering (include/exclude types)</li>
                    <li><strong>Stage 6:</strong> Cross-Encoder Re-ranking (precision boost)</li>
                </ul>

                <h3>‚ö° Tag Boosting</h3>
                <p>When your query matches document tags:</p>
                <ul>
                    <li>BM25 score gets 5x multiplier</li>
                    <li>RRF fusion gets 1.5-2.0x aggressive boost</li>
                    <li>Cross-encoder re-ranking is skipped (already perfect)</li>
                    <li>Result marked with ‚ö° Yes indicator</li>
                </ul>

                <p style="margin-top: 20px; padding-top: 12px; border-top: 1px solid #333; font-size: 11px; color: #888;">
                    <em>Hover over any score label or control to see detailed tooltips!</em>
                </p>
            `;

            inspectorContent.replaceChildren(helpPanel);
        }

        // ========================================
        // Initialization
        // ========================================

        async function initialize() {
            restoreState();
            await loadVaults();
            syncUIWithState();
            setupEventHandlers();
            console.log('Temoa initialized', state);
        }

        function migrateFilterState(oldState) {
            // Migrate old filter state to new Obsidian-compatible syntax
            if (!oldState.filterParams) return oldState

            const { filterText, tagMatchMode, parsedFilters } = oldState.filterParams

            // Migrate comma syntax based on tagMatchMode
            if (filterText && (tagMatchMode === 'any' || tagMatchMode === 'all')) {
                // Convert tag:a,b syntax
                const migratedText = filterText.replace(
                    /(tag|path|file|type|status):([^,\s]+(?:,[^,\s]+)+)/g,
                    (match, filterType, values) => {
                        const parts = values.split(',').map(v => v.trim())
                        if (tagMatchMode === 'any') {
                            // ANY mode: tag:a,b ‚Üí tag:a OR tag:b
                            return parts.map(v => `${filterType}:${v}`).join(' OR ')
                        } else {
                            // ALL mode: tag:a,b ‚Üí tag:a tag:b (implicit AND)
                            return parts.map(v => `${filterType}:${v}`).join(' ')
                        }
                    }
                )

                oldState.filterParams.filterText = migratedText
                console.log('Migrated filter syntax:', filterText, '‚Üí', migratedText)
            }

            // Remove deprecated fields
            delete oldState.filterParams.tagMatchMode
            delete oldState.filterParams.parsedFilters

            return oldState
        }

        function restoreState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY)
                if (saved) {
                    let data = JSON.parse(saved)

                    // Migrate old filter state
                    data = migrateFilterState(data)

                    if (data.viewMode) state.viewMode = data.viewMode
                    if (data.searchHistory) state.searchHistory = data.searchHistory
                    if (data.fetchParams) state.fetchParams = { ...state.fetchParams, ...data.fetchParams }
                    if (data.liveParams) state.liveParams = { ...state.liveParams, ...data.liveParams }
                    if (data.filterParams) state.filterParams = { ...state.filterParams, ...data.filterParams }
                    if (data.vault) state.vault = data.vault
                }
            } catch (err) {
                console.error('Failed to restore state:', err)
            }
        }

        function saveState() {
            try {
                const data = {
                    viewMode: state.viewMode,
                    searchHistory: state.searchHistory,
                    fetchParams: state.fetchParams,
                    liveParams: state.liveParams,
                    filterParams: state.filterParams,
                    vault: state.vault
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (err) {
                console.error('Failed to save state:', err);
            }
        }

        function syncUIWithState() {
            // Set view mode
            switchView(state.viewMode, false);

            // Render search history
            renderSearchHistory();

            // Sync explorer controls if in explorer mode
            syncExplorerControls();
        }

        function syncExplorerControls() {
            const fetchHybrid = document.getElementById('fetch-hybrid');
            const fetchBalanceValue = document.getElementById('fetch-balance-value');
            const fetchLimit = document.getElementById('fetch-limit');
            const fetchRerank = document.getElementById('fetch-rerank');
            const fetchExpand = document.getElementById('fetch-expand');

            const liveBalance = document.getElementById('live-balance');
            const liveBalanceValue = document.getElementById('live-balance-value');
            const liveTags = document.getElementById('live-tags');
            const liveTime = document.getElementById('live-time');

            if (!fetchHybrid) return; // Controls not loaded yet

            // Fetch controls
            const fetchWeight = Math.round(state.fetchParams.hybrid_weight * 100);
            fetchHybrid.value = fetchWeight;
            fetchBalanceValue.textContent = `${100-fetchWeight}/${fetchWeight}`;
            fetchLimit.value = state.fetchParams.limit;
            fetchRerank.checked = state.fetchParams.rerank;
            fetchExpand.checked = state.fetchParams.expand;

            // Live controls
            const liveWeight = Math.round(state.liveParams.mix_balance * 100);
            liveBalance.value = liveWeight;
            liveBalanceValue.textContent = `${100-liveWeight}/${liveWeight}`;
            liveTags.value = state.liveParams.tag_multiplier;
            liveTime.value = state.liveParams.time_weight;

            // Filter controls
            const filterInput = document.getElementById('filter-input')

            if (filterInput) {
                filterInput.value = state.filterParams.filterText || ''
                updateFilterChips(state.filterParams.filterText)
            }
        }

        async function loadVaults() {
            try {
                const res = await fetch('/vaults');
                const data = await res.json();
                state.vaults = data.vaults || [];

                const vaultSelect = document.getElementById('vault-select');
                vaultSelect.innerHTML = state.vaults.map(v =>
                    `<option value="${v.name}" ${v.is_default ? 'selected' : ''}>${v.name}${v.is_default ? ' (default)' : ''}</option>`
                ).join('');

                const defaultVault = state.vaults.find(v => v.is_default);
                state.vault = state.vault || defaultVault?.name || state.vaults[0]?.name;
            } catch (err) {
                console.error('Failed to load vaults:', err);
            }
        }

        // ========================================
        // Event Handlers
        // ========================================

        function setupEventHandlers() {
            // View toggle
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const view = btn.dataset.view;
                    switchView(view, true);
                });
            });

            // Search
            document.getElementById('run-btn').addEventListener('click', runSearch);
            document.getElementById('query-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') runSearch();
            });

            // Vault selector
            document.getElementById('vault-select').addEventListener('change', (e) => {
                state.vault = e.target.value;
                saveState();
            });

            // History dropdown
            setupHistoryDropdown();

            // Keyboard shortcuts removed - were interfering with typing

            // Help button
            const helpBtn = document.getElementById('help-btn');
            if (helpBtn) {
                helpBtn.addEventListener('click', showHelpPanel);
            }

            // Explorer controls setup (only if elements exist)
            setupExplorerControls();

            // Mobile accordion for explorer
            setupMobileAccordion();
        }

        function setupExplorerControls() {
            const fetchHybrid = document.getElementById('fetch-hybrid');
            const fetchBalanceValue = document.getElementById('fetch-balance-value');
            const fetchLimit = document.getElementById('fetch-limit');
            const fetchRerank = document.getElementById('fetch-rerank');
            const fetchExpand = document.getElementById('fetch-expand');
            const fetchSection = document.getElementById('fetch-section');

            const liveBalance = document.getElementById('live-balance');
            const liveBalanceValue = document.getElementById('live-balance-value');
            const liveTags = document.getElementById('live-tags');
            const liveTime = document.getElementById('live-time');

            const resetMixBtn = document.getElementById('reset-mix-btn');
            const exportBtn = document.getElementById('export-btn');

            if (!fetchHybrid) return; // Elements not loaded yet

            // Fetch controls (mark as dirty when changed)
            fetchHybrid.addEventListener('input', () => {
                const val = parseInt(fetchHybrid.value);
                fetchBalanceValue.textContent = `${100-val}/${val}`;
                state.fetchParams.hybrid_weight = val / 100;
                markFetchDirty();
                saveState();
            });

            fetchLimit.addEventListener('change', () => {
                state.fetchParams.limit = parseInt(fetchLimit.value);
                markFetchDirty();
                saveState();
            });

            fetchRerank.addEventListener('change', () => {
                state.fetchParams.rerank = fetchRerank.checked;
                markFetchDirty();
                saveState();
            });

            fetchExpand.addEventListener('change', () => {
                state.fetchParams.expand = fetchExpand.checked;
                markFetchDirty();
                saveState();
            });

            // Live controls (instant remix when results exist)
            liveBalance.addEventListener('input', () => {
                const val = parseInt(liveBalance.value);
                liveBalanceValue.textContent = `${100-val}/${val}`;
                state.liveParams.mix_balance = val / 100;
                if (state.rawResults.length > 0) {
                    remixAndRender();
                }
                saveState();
            });

            liveTags.addEventListener('change', () => {
                state.liveParams.tag_multiplier = parseFloat(liveTags.value);
                if (state.rawResults.length > 0) {
                    remixAndRender();
                }
                saveState();
            });

            liveTime.addEventListener('change', () => {
                state.liveParams.time_weight = parseFloat(liveTime.value);
                if (state.rawResults.length > 0) {
                    remixAndRender();
                }
                saveState();
            });

            // Action buttons
            resetMixBtn.addEventListener('click', resetMix);
            exportBtn.addEventListener('click', () => {
                if (state.rawResults.length === 0) {
                    alert('No results to export');
                    return;
                }
                const dataStr = JSON.stringify(state.remixedResults || state.rawResults, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const exportFileDefaultName = `temoa-results-${Date.now()}.json`;
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            });

            // Filter controls
            const filterInput = document.getElementById('filter-input')
            const filterHelpToggle = document.getElementById('filter-help-toggle')
            const filterHelp = document.getElementById('filter-help')

            if (filterInput) {
                // Update filters on input
                filterInput.addEventListener('input', handleFilterInput)

                // Help toggle
                if (filterHelpToggle && filterHelp) {
                    filterHelpToggle.addEventListener('click', () => {
                        const isVisible = filterHelp.style.display !== 'none'
                        filterHelp.style.display = isVisible ? 'none' : 'block'
                    })
                }
            }
        }

        function markFetchDirty() {
            const fetchSection = document.getElementById('fetch-section');
            if (!fetchSection) return;

            if (state.lastFetchParams) {
                const current = state.fetchParams;
                const last = state.lastFetchParams;
                const changed =
                    current.hybrid_weight !== last.hybrid_weight ||
                    current.limit !== last.limit ||
                    current.rerank !== last.rerank ||
                    current.expand !== last.expand;

                if (changed) {
                    fetchSection.classList.add('dirty');
                    state.fetchParamsChanged = true;
                } else {
                    fetchSection.classList.remove('dirty');
                    state.fetchParamsChanged = false;
                }
            }
        }

        function resetMix() {
            // Reset to defaults
            state.liveParams = {
                mix_balance: 0.5,
                tag_multiplier: 5.0,
                time_weight: 1.0
            };

            // Update UI
            const liveBalance = document.getElementById('live-balance');
            const liveBalanceValue = document.getElementById('live-balance-value');
            const liveTags = document.getElementById('live-tags');
            const liveTime = document.getElementById('live-time');

            if (liveBalance) {
                liveBalance.value = 50;
                liveBalanceValue.textContent = '50/50';
                liveTags.value = 5.0;
                liveTime.value = 1.0;
            }

            // Remix if results exist
            if (state.rawResults.length > 0) {
                remixAndRender();
            }

            saveState();
        }

        function setupMobileAccordion() {
            const controlsPane = document.getElementById('controls-pane');
            if (!controlsPane) return;

            if (window.innerWidth <= 768) {
                const controlsHeader = controlsPane.querySelector('.pane-header');
                if (controlsHeader) {
                    controlsHeader.addEventListener('click', () => {
                        controlsPane.classList.toggle('expanded');
                    });
                }
            }
        }

        // ========================================
        // View Switching
        // ========================================

        function switchView(view, save = true) {
            state.viewMode = view;

            // Update toggle buttons
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Show/hide containers
            document.querySelector('.list-view-container').classList.toggle('active', view === 'list');
            document.querySelector('.explorer-view-container').classList.toggle('active', view === 'explorer');

            // Re-render results for the new view if we have results
            if (state.rawResults.length > 0) {
                if (view === 'explorer') {
                    renderExplorerResults();
                } else {
                    renderListResults();
                }
            }

            if (save) {
                saveState();
            }
        }

        function toggleView() {
            const newView = state.viewMode === 'list' ? 'explorer' : 'list';
            switchView(newView, true);
        }

        // ========================================
        // Search Flow
        // ========================================

        async function runSearch() {
            const query = document.getElementById('query-input').value.trim();
            if (!query) return;

            const mainEl = state.viewMode === 'list'
                ? document.querySelector('.list-main')
                : document.querySelector('#results-pane .pane-content');

            mainEl.innerHTML = '<div class="loading"><div class="spinner"></div><span>Searching...</span></div>';

            const runBtn = document.getElementById('run-btn');
            runBtn.disabled = true;

            try {
                const params = new URLSearchParams({
                    q: query,
                    vault: state.vault || '',
                    limit: state.fetchParams.limit,
                    hybrid_weight: state.fetchParams.hybrid_weight,
                    rerank: state.fetchParams.rerank,
                    expand: state.fetchParams.expand,
                    harness: 'true'
                });

                const response = await fetch(`/search?${params}`);
                if (!response.ok) throw new Error(`Search failed: ${response.statusText}`);

                const data = await response.json();
                state.rawResults = data.results || [];
                state.pipelineData = data.pipeline_stages || null;
                state.query = query;

                // Mark fetch params as clean
                state.lastFetchParams = { ...state.fetchParams };
                const fetchSection = document.getElementById('fetch-section');
                if (fetchSection) {
                    fetchSection.classList.remove('dirty');
                }
                state.fetchParamsChanged = false;

                addToSearchHistory(query);
                remixAndRender();

            } catch (err) {
                console.error('Search error:', err);
                mainEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div class="empty-state-text">Search failed<br>${err.message}</div>
                    </div>
                `;
            } finally {
                runBtn.disabled = false;
            }
        }

        // ========================================
        // Filter Parsing & Application
        // ========================================

        // ========================================
        // Filter Lexer - Tokenization
        // ========================================

        class FilterLexer {
            constructor(input) {
                this.input = input
                this.pos = 0
                this.tokens = []
            }

            tokenize() {
                while (this.pos < this.input.length) {
                    this.skipWhitespace()
                    if (this.pos >= this.input.length) break

                    const ch = this.input[this.pos]

                    // Quoted string
                    if (ch === '"' || ch === "'") {
                        this.tokens.push(this.readQuotedString(ch))
                        continue
                    }

                    // Special characters
                    if (ch === '(') {
                        this.tokens.push({ type: 'LPAREN', value: '(' })
                        this.pos++
                        continue
                    }
                    if (ch === ')') {
                        this.tokens.push({ type: 'RPAREN', value: ')' })
                        this.pos++
                        continue
                    }
                    if (ch === '[') {
                        this.tokens.push({ type: 'LBRACKET', value: '[' })
                        this.pos++
                        continue
                    }
                    if (ch === ']') {
                        this.tokens.push({ type: 'RBRACKET', value: ']' })
                        this.pos++
                        continue
                    }
                    if (ch === ':') {
                        this.tokens.push({ type: 'COLON', value: ':' })
                        this.pos++
                        continue
                    }
                    if (ch === ',') {
                        this.tokens.push({ type: 'COMMA', value: ',' })
                        this.pos++
                        continue
                    }

                    // Minus sign (potential NOT operator)
                    if (ch === '-' && (this.pos + 1 < this.input.length) && !this.isWhitespace(this.input[this.pos + 1])) {
                        this.tokens.push({ type: 'NOT', value: '-' })
                        this.pos++
                        continue
                    }

                    // Word (could be OR, AND, or regular text)
                    const word = this.readWord()
                    if (word) {
                        const upper = word.toUpperCase()
                        if (upper === 'OR') {
                            this.tokens.push({ type: 'OR', value: word })
                        } else if (upper === 'AND') {
                            this.tokens.push({ type: 'AND', value: word })
                        } else {
                            this.tokens.push({ type: 'TEXT', value: word })
                        }
                    }
                }

                this.tokens.push({ type: 'EOF', value: '' })
                return this.tokens
            }

            readQuotedString(quoteChar) {
                this.pos++ // Skip opening quote
                let value = ''
                let escaped = false

                while (this.pos < this.input.length) {
                    const ch = this.input[this.pos]

                    if (escaped) {
                        value += ch
                        escaped = false
                        this.pos++
                        continue
                    }

                    if (ch === '\\') {
                        escaped = true
                        this.pos++
                        continue
                    }

                    if (ch === quoteChar) {
                        this.pos++ // Skip closing quote
                        break
                    }

                    value += ch
                    this.pos++
                }

                return { type: 'QUOTED_STRING', value: value }
            }

            readWord() {
                let word = ''
                while (this.pos < this.input.length && !this.isWhitespace(this.input[this.pos]) && !this.isSpecialChar(this.input[this.pos])) {
                    word += this.input[this.pos]
                    this.pos++
                }
                return word
            }

            skipWhitespace() {
                while (this.pos < this.input.length && this.isWhitespace(this.input[this.pos])) {
                    this.pos++
                }
            }

            isWhitespace(ch) {
                return ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r'
            }

            isSpecialChar(ch) {
                return ch === '(' || ch === ')' || ch === '[' || ch === ']' || ch === ':' || ch === ',' || ch === '"' || ch === "'"
            }
        }

        // ========================================
        // Filter Parser - AST Building
        // ========================================

        class FilterParser {
            constructor(tokens) {
                this.tokens = tokens
                this.pos = 0
            }

            parse() {
                return this.parseExpression()
            }

            current() {
                return this.tokens[this.pos]
            }

            peek(offset = 1) {
                return this.tokens[this.pos + offset]
            }

            consume(expectedType) {
                const token = this.current()
                if (token.type !== expectedType) {
                    throw new Error(`Expected ${expectedType}, got ${token.type}`)
                }
                this.pos++
                return token
            }

            consumeIf(type) {
                if (this.current().type === type) {
                    return this.consume(type)
                }
                return null
            }

            parseExpression() {
                // Expression ‚Üí OrTerm (OR OrTerm)*
                let left = this.parseOrTerm()

                while (this.current().type === 'OR') {
                    this.consume('OR')
                    const right = this.parseOrTerm()
                    left = {
                        type: 'OR',
                        left: left,
                        right: right
                    }
                }

                return left
            }

            parseOrTerm() {
                // OrTerm ‚Üí AndTerm (AND AndTerm)*
                let left = this.parseAndTerm()

                while (this.current().type === 'AND' || this.isImplicitAnd()) {
                    if (this.current().type === 'AND') {
                        this.consume('AND')
                    }
                    const right = this.parseAndTerm()
                    left = {
                        type: 'AND',
                        left: left,
                        right: right
                    }
                }

                return left
            }

            isImplicitAnd() {
                // Implicit AND when we see a primary expression (not OR, EOF, RPAREN)
                const curr = this.current()
                return (
                    curr.type !== 'OR' &&
                    curr.type !== 'EOF' &&
                    curr.type !== 'RPAREN' &&
                    curr.type !== 'RBRACKET' &&
                    (curr.type === 'NOT' || curr.type === 'TEXT' || curr.type === 'LPAREN' || curr.type === 'LBRACKET')
                )
            }

            parseAndTerm() {
                // AndTerm ‚Üí NOT? Primary
                if (this.current().type === 'NOT') {
                    this.consume('NOT')
                    const expr = this.parsePrimary()
                    return {
                        type: 'NOT',
                        expr: expr
                    }
                }

                return this.parsePrimary()
            }

            parsePrimary() {
                // Primary ‚Üí Property | Filter | Group | Text
                const curr = this.current()

                // Property: [property:value]
                if (curr.type === 'LBRACKET') {
                    return this.parseProperty()
                }

                // Group: (expression)
                if (curr.type === 'LPAREN') {
                    this.consume('LPAREN')
                    const expr = this.parseExpression()
                    this.consume('RPAREN')
                    return expr
                }

                // Filter: text:value or text:value,value,value
                if (curr.type === 'TEXT' && this.peek() && this.peek().type === 'COLON') {
                    return this.parseFilter()
                }

                // Plain text (becomes part of query text)
                if (curr.type === 'TEXT' || curr.type === 'QUOTED_STRING') {
                    const token = this.consume(curr.type)
                    return {
                        type: 'TEXT',
                        value: token.value
                    }
                }

                throw new Error(`Unexpected token: ${curr.type} (${curr.value})`)
            }

            parseProperty() {
                // Property ‚Üí [ TEXT : value ]
                this.consume('LBRACKET')
                const filterType = this.consume('TEXT').value
                this.consume('COLON')
                const value = this.parseValue()
                this.consume('RBRACKET')

                return {
                    type: 'FILTER',
                    filterType: filterType,
                    value: value,
                    isProperty: true
                }
            }

            parseFilter() {
                // Filter ‚Üí TEXT : value
                const filterType = this.consume('TEXT').value
                this.consume('COLON')

                // Check for comma-separated values (backward compatibility)
                const values = []
                values.push(this.parseValue())

                while (this.current().type === 'COMMA') {
                    this.consume('COMMA')
                    values.push(this.parseValue())
                }

                // If multiple values, convert to OR chain
                if (values.length === 1) {
                    return {
                        type: 'FILTER',
                        filterType: filterType,
                        value: values[0],
                        isProperty: false
                    }
                } else {
                    // Create OR chain: tag:a,b,c ‚Üí tag:a OR tag:b OR tag:c
                    let orChain = {
                        type: 'FILTER',
                        filterType: filterType,
                        value: values[0],
                        isProperty: false
                    }

                    for (let i = 1; i < values.length; i++) {
                        orChain = {
                            type: 'OR',
                            left: orChain,
                            right: {
                                type: 'FILTER',
                                filterType: filterType,
                                value: values[i],
                                isProperty: false
                            }
                        }
                    }

                    return orChain
                }
            }

            parseValue() {
                const curr = this.current()
                if (curr.type === 'QUOTED_STRING') {
                    return this.consume('QUOTED_STRING').value
                }
                if (curr.type === 'TEXT') {
                    return this.consume('TEXT').value
                }
                throw new Error(`Expected value, got ${curr.type}`)
            }
        }

        // ========================================
        // AST Evaluation
        // ========================================

        function extractServerFilters(ast) {
            // Walk AST and extract type/status filters for server-side filtering
            const filters = {
                include_types: [],
                exclude_types: [],
                include_statuses: [],
                exclude_statuses: []
            }

            function walk(node, negated = false) {
                if (!node) return

                switch (node.type) {
                    case 'OR':
                    case 'AND':
                        walk(node.left, negated)
                        walk(node.right, negated)
                        break

                    case 'NOT':
                        walk(node.expr, !negated)
                        break

                    case 'FILTER':
                        if (node.filterType === 'type') {
                            if (negated) {
                                filters.exclude_types.push(node.value)
                            } else {
                                filters.include_types.push(node.value)
                            }
                        } else if (node.filterType === 'status') {
                            if (negated) {
                                filters.exclude_statuses.push(node.value)
                            } else {
                                filters.include_statuses.push(node.value)
                            }
                        }
                        break

                    case 'TEXT':
                        // Ignore plain text
                        break
                }
            }

            walk(ast)
            return filters
        }

        function extractQueryText(ast) {
            // Extract plain text nodes from AST (non-filter terms)
            const textParts = []

            function walk(node) {
                if (!node) return

                switch (node.type) {
                    case 'OR':
                    case 'AND':
                        walk(node.left)
                        walk(node.right)
                        break

                    case 'NOT':
                        walk(node.expr)
                        break

                    case 'TEXT':
                        textParts.push(node.value)
                        break

                    case 'FILTER':
                        // Ignore filters
                        break
                }
            }

            walk(ast)
            return textParts.join(' ').trim()
        }

        function evaluateAST(node, result, queryText) {
            // Recursively evaluate AST against a result object
            if (!node) return true

            switch (node.type) {
                case 'OR':
                    return evaluateAST(node.left, result, queryText) || evaluateAST(node.right, result, queryText)

                case 'AND':
                    return evaluateAST(node.left, result, queryText) && evaluateAST(node.right, result, queryText)

                case 'NOT':
                    return !evaluateAST(node.expr, result, queryText)

                case 'FILTER':
                    return evaluateFilter(node, result)

                case 'TEXT':
                    // Plain text doesn't filter (it's part of the search query)
                    return true

                default:
                    return true
            }
        }

        function evaluateFilter(filterNode, result) {
            // Evaluate a single filter against a result
            const filterType = filterNode.filterType
            const filterValue = filterNode.value.toLowerCase()
            const fm = result.frontmatter || {}

            switch (filterType) {
                case 'tag': {
                    const resultTags = (fm.tags || []).map(t => t.toLowerCase())
                    return resultTags.includes(filterValue)
                }

                case 'path': {
                    const path = (result.file_path || '').toLowerCase()
                    return path.includes(filterValue)
                }

                case 'file': {
                    const filename = (result.title || '').toLowerCase()
                    return filename.includes(filterValue)
                }

                case 'type': {
                    const resultType = (fm.type || '').toLowerCase()
                    return resultType === filterValue
                }

                case 'status': {
                    const resultStatus = (fm.status || '').toLowerCase()
                    return resultStatus === filterValue
                }

                default:
                    return true
            }
        }

        function parseFilterSyntax(input) {
            // Parse Obsidian-style filter syntax using lexer + parser
            // Returns: {ast: ASTNode, queryText: string, error: string|null}

            if (!input || input.trim() === '') {
                return {
                    ast: null,
                    queryText: '',
                    error: null
                }
            }

            try {
                const lexer = new FilterLexer(input)
                const tokens = lexer.tokenize()
                const parser = new FilterParser(tokens)
                const ast = parser.parse()

                // Extract query text (non-filter TEXT nodes)
                const queryText = extractQueryText(ast)

                return {
                    ast: ast,
                    queryText: queryText,
                    error: null
                }
            } catch (err) {
                // User-friendly error messages
                console.error('Filter parse error:', err)
                return {
                    ast: null,
                    queryText: input,
                    error: `Parse error: ${err.message}`
                }
            }
        }

        function applyFilters(results, ast, queryText) {
            // Apply AST-based filters to results
            // Returns filtered array

            if (!results || results.length === 0) return results
            if (!ast) return results

            return results.filter(result => evaluateAST(ast, result, queryText))
        }

        function updateFilterChips(filterText) {
            // Render active filter text as chip
            const chipsContainer = document.getElementById('filter-chips')
            if (!chipsContainer) return

            if (!filterText || filterText.trim() === '') {
                chipsContainer.innerHTML = ''
                return
            }

            // Escape HTML to prevent XSS
            const escaped = filterText
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;')

            chipsContainer.innerHTML = `
                <div class="filter-chip">
                    ${escaped}
                </div>
            `
        }


        function handleFilterInput() {
            // Parse filter input and update state
            const filterInput = document.getElementById('filter-input')
            if (!filterInput) return

            const filterText = filterInput.value
            const parsed = parseFilterSyntax(filterText)

            if (parsed.error) {
                // Show error message
                console.error('Filter parse error:', parsed.error)
                // TODO: Show user-friendly error in UI
                updateFilterChips(filterText)
                return
            }

            state.filterParams.filterText = filterText
            state.filterParams.ast = parsed.ast

            // Extract server filters
            const newServerFilters = parsed.ast ? extractServerFilters(parsed.ast) : {
                include_types: [],
                exclude_types: [],
                include_statuses: [],
                exclude_statuses: []
            }

            // Check if server filters changed (would require new fetch)
            const oldServerFilters = state.filterParams.serverFilters || {}
            const serverFiltersChanged =
                JSON.stringify(newServerFilters.include_types) !== JSON.stringify(oldServerFilters.include_types) ||
                JSON.stringify(newServerFilters.exclude_types) !== JSON.stringify(oldServerFilters.exclude_types) ||
                JSON.stringify(newServerFilters.include_statuses) !== JSON.stringify(oldServerFilters.include_statuses) ||
                JSON.stringify(newServerFilters.exclude_statuses) !== JSON.stringify(oldServerFilters.exclude_statuses)

            state.filterParams.serverFilters = newServerFilters

            updateFilterChips(filterText)
            saveState()

            if (serverFiltersChanged && state.rawResults.length > 0) {
                // Server filters changed, need to re-fetch
                console.log('Server filters changed, re-fetching results')
                // TODO: Trigger new search with server filters
                // For now, just re-evaluate client-side
                remixAndRender()
            } else {
                // Just re-evaluate client-side filters
                remixAndRender()
            }
        }

        function remixAndRender() {
            // Client-side remix: re-blend semantic/BM25, apply tag/time multipliers
            if (!state.rawResults || state.rawResults.length === 0) return;

            const { mix_balance, tag_multiplier, time_weight } = state.liveParams;

            // Clone and re-score
            const remixed = state.rawResults.map(r => {
                const clone = { ...r };

                // Re-blend semantic + BM25 scores
                const semanticScore = clone.similarity_score || 0;
                const bm25Score = clone.bm25_score || 0;

                // Normalize BM25 to 0-1 range (assuming max ~10)
                const normalizedBM25 = Math.min(bm25Score / 10, 1);

                // Mix: 0 = all semantic, 1 = all BM25
                let mixedScore = (1 - mix_balance) * semanticScore + mix_balance * normalizedBM25;

                // Apply tag multiplier if tag boosted
                if (clone.tag_boosted) {
                    mixedScore *= tag_multiplier;
                }

                // Apply time boost
                if (clone.time_boost && time_weight > 0) {
                    mixedScore *= (1 + clone.time_boost * time_weight);
                }

                clone.final_score = mixedScore;
                return clone;
            });

            // Sort by final score descending
            remixed.sort((a, b) => b.final_score - a.final_score);

            // Apply client-side filters
            const { ast } = state.filterParams
            const filtered = applyFilters(remixed, ast, '')

            state.remixedResults = filtered;

            if (state.viewMode === 'list') {
                renderListResults();
            } else {
                renderExplorerResults();
            }
        }

        function renderListResults() {
            const mainEl = document.querySelector('.list-main');

            const results = state.remixedResults.length > 0 ? state.remixedResults : state.rawResults;

            if (!results || results.length === 0) {
                mainEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <div class="empty-state-text">No results found</div>
                    </div>
                `;
                return;
            }

            // Create results table
            const table = document.createElement('div');
            table.className = 'results-table';

            results.forEach(result => {
                const card = createListResultCard(result);
                table.appendChild(card);
            });

            mainEl.replaceChildren(table);
        }

        function createListResultCard(result) {
            const card = document.createElement('div');
            card.className = 'result-row';

            // Title row with badges
            const titleRow = document.createElement('div');
            titleRow.style.display = 'flex';
            titleRow.style.justifyContent = 'space-between';
            titleRow.style.alignItems = 'flex-start';
            titleRow.style.gap = '8px';
            titleRow.style.marginBottom = '4px';

            const titleLink = document.createElement('a');
            titleLink.className = 'result-title-link';
            titleLink.href = result.obsidian_uri;
            titleLink.textContent = result.title || result.relative_path;
            titleRow.appendChild(titleLink);

            // Badges
            const badgesDiv = document.createElement('div');
            badgesDiv.style.display = 'flex';
            badgesDiv.style.gap = '4px';
            badgesDiv.style.flexShrink = '0';

            if (result.frontmatter?.type) {
                const type = Array.isArray(result.frontmatter.type)
                    ? result.frontmatter.type.join(', ')
                    : String(result.frontmatter.type);
                const badge = document.createElement('span');
                badge.className = 'type-badge';
                badge.textContent = type;
                badgesDiv.appendChild(badge);
            }

            if (result.frontmatter?.project) {
                const vaultName = result.obsidian_uri.split('/')[3];
                let project = result.frontmatter.project;
                if (Array.isArray(project)) project = project[0];
                const projectName = String(project).replace(/[\[\]]/g, '');
                const projectUri = `obsidian://vault/${vaultName}/${encodeURIComponent(projectName)}`;
                const badge = document.createElement('a');
                badge.className = 'project-badge';
                badge.textContent = projectName;
                badge.href = projectUri;
                badgesDiv.appendChild(badge);
            }

            if (badgesDiv.children.length > 0) {
                titleRow.appendChild(badgesDiv);
            }

            card.appendChild(titleRow);

            // Path
            const pathDiv = document.createElement('div');
            pathDiv.className = 'result-path';
            pathDiv.textContent = result.relative_path;
            card.appendChild(pathDiv);

            // Dates
            if (result.frontmatter?.created || result.frontmatter?.modified) {
                const datesDiv = document.createElement('div');
                datesDiv.className = 'result-dates';
                const dateParts = [];
                if (result.frontmatter.created) {
                    dateParts.push(`Created: ${formatDate(result.frontmatter.created)}`);
                }
                if (result.frontmatter.modified) {
                    dateParts.push(`Modified: ${formatDate(result.frontmatter.modified)}`);
                }
                datesDiv.textContent = dateParts.join('  ‚Ä¢  ');
                card.appendChild(datesDiv);
            }

            // Description
            if (result.description) {
                const desc = document.createElement('div');
                desc.className = 'result-description';
                desc.textContent = result.description;
                card.appendChild(desc);
            }

            // Tags
            if (result.tags && result.tags.length > 0) {
                const tagsDiv = document.createElement('div');
                tagsDiv.className = 'result-tags';
                result.tags.slice(0, 5).forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'tag';
                    tagSpan.textContent = `#${tag}`;
                    tagsDiv.appendChild(tagSpan);
                });
                if (result.tags.length > 5) {
                    const more = document.createElement('span');
                    more.className = 'tag';
                    more.textContent = `+${result.tags.length - 5} more`;
                    tagsDiv.appendChild(more);
                }
                card.appendChild(tagsDiv);
            }

            return card;
        }

        function renderExplorerResults() {
            const resultsEl = document.querySelector('#results-pane .pane-content');
            const resultCount = document.getElementById('result-count');

            const results = state.remixedResults.length > 0 ? state.remixedResults : state.rawResults;

            if (!results || results.length === 0) {
                resultsEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <div class="empty-state-text">No results found</div>
                    </div>
                `;
                if (resultCount) resultCount.textContent = '';
                return;
            }

            // Update result count
            if (resultCount) resultCount.textContent = `(${results.length})`;

            // Create results table
            const table = document.createElement('div');
            table.className = 'results-table';

            results.forEach(result => {
                const card = createExplorerResultCard(result);
                table.appendChild(card);
            });

            resultsEl.replaceChildren(table);
        }

        function createExplorerResultCard(result) {
            const card = document.createElement('div');
            card.className = 'result-row';
            card.dataset.resultId = result.relative_path;

            // Click handler for inspector
            card.addEventListener('click', () => {
                selectResult(result);
            });

            // Title row with badges
            const titleRow = document.createElement('div');
            titleRow.style.display = 'flex';
            titleRow.style.justifyContent = 'space-between';
            titleRow.style.alignItems = 'flex-start';
            titleRow.style.gap = '8px';
            titleRow.style.marginBottom = '4px';

            const titleLink = document.createElement('a');
            titleLink.className = 'result-title-link';
            titleLink.href = result.obsidian_uri;
            titleLink.textContent = result.title || result.relative_path;
            titleLink.addEventListener('click', (e) => {
                e.stopPropagation();  // Don't trigger card click
            });
            titleRow.appendChild(titleLink);

            // Badges
            const badgesDiv = document.createElement('div');
            badgesDiv.style.display = 'flex';
            badgesDiv.style.gap = '4px';
            badgesDiv.style.flexShrink = '0';

            if (result.frontmatter?.type) {
                const type = Array.isArray(result.frontmatter.type)
                    ? result.frontmatter.type.join(', ')
                    : String(result.frontmatter.type);
                const badge = document.createElement('span');
                badge.className = 'type-badge';
                badge.textContent = type;
                badgesDiv.appendChild(badge);
            }

            if (result.frontmatter?.project) {
                const vaultName = result.obsidian_uri.split('/')[3];
                let project = result.frontmatter.project;
                if (Array.isArray(project)) project = project[0];
                const projectName = String(project).replace(/[\[\]]/g, '');
                const projectUri = `obsidian://vault/${vaultName}/${encodeURIComponent(projectName)}`;
                const badge = document.createElement('a');
                badge.className = 'project-badge';
                badge.textContent = projectName;
                badge.href = projectUri;
                badge.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                badgesDiv.appendChild(badge);
            }

            if (badgesDiv.children.length > 0) {
                titleRow.appendChild(badgesDiv);
            }

            card.appendChild(titleRow);

            // Path
            const pathDiv = document.createElement('div');
            pathDiv.className = 'result-path';
            pathDiv.textContent = result.relative_path;
            card.appendChild(pathDiv);

            // Dates
            if (result.frontmatter?.created || result.frontmatter?.modified) {
                const datesDiv = document.createElement('div');
                datesDiv.className = 'result-dates';
                const dateParts = [];
                if (result.frontmatter.created) {
                    dateParts.push(`Created: ${formatDate(result.frontmatter.created)}`);
                }
                if (result.frontmatter.modified) {
                    dateParts.push(`Modified: ${formatDate(result.frontmatter.modified)}`);
                }
                datesDiv.textContent = dateParts.join('  ‚Ä¢  ');
                card.appendChild(datesDiv);
            }

            // Description
            if (result.description) {
                const desc = document.createElement('div');
                desc.className = 'result-description';
                desc.textContent = result.description;
                card.appendChild(desc);
            }

            // Tags
            if (result.tags && result.tags.length > 0) {
                const tagsDiv = document.createElement('div');
                tagsDiv.className = 'result-tags';
                result.tags.slice(0, 5).forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'tag';
                    tagSpan.textContent = `#${tag}`;
                    tagsDiv.appendChild(tagSpan);
                });
                if (result.tags.length > 5) {
                    const more = document.createElement('span');
                    more.className = 'tag';
                    more.textContent = `+${result.tags.length - 5} more`;
                    tagsDiv.appendChild(more);
                }
                card.appendChild(tagsDiv);
            }

            // Scores
            const scoresDiv = document.createElement('div');
            scoresDiv.className = 'result-scores-compact';
            const scoreParts = [];

            if (result.similarity_score !== undefined) {
                scoreParts.push(`${(result.similarity_score * 100).toFixed(1)}% sem`);
            }
            if (result.bm25_score !== undefined) {
                scoreParts.push(`${result.bm25_score.toFixed(1)} bm25`);
            }
            if (result.rrf_score !== undefined) {
                scoreParts.push(`${result.rrf_score.toFixed(4)} rrf`);
            }
            if (result.cross_encoder_score !== undefined) {
                scoreParts.push(`${result.cross_encoder_score.toFixed(3)} xe`);
            }
            if (result.tag_boosted) {
                scoreParts.push('tag‚ö°');
            }
            if (result.time_boost !== undefined && result.time_boost > 0) {
                scoreParts.push(`time+${(result.time_boost * 100).toFixed(0)}%`);
            }
            if (result.final_score !== undefined) {
                scoreParts.push(`final=${result.final_score.toFixed(3)}`);
            }

            scoresDiv.textContent = scoreParts.join(' | ');
            card.appendChild(scoresDiv);

            return card;
        }

        // ========================================
        // Search History
        // ========================================

        function addToSearchHistory(query) {
            const trimmed = query.trim();
            if (!trimmed) return;

            state.searchHistory = state.searchHistory.filter(q => q !== trimmed);
            state.searchHistory.unshift(trimmed);

            if (state.searchHistory.length > 10) {
                state.searchHistory = state.searchHistory.slice(0, 10);
            }

            saveState();
            renderSearchHistory();
        }

        let historySelectedIndex = -1;

        function setupHistoryDropdown() {
            const input = document.getElementById('query-input');
            const dropdown = document.getElementById('history-dropdown');

            // Show dropdown on focus (if there's history)
            input.addEventListener('focus', () => {
                if (state.searchHistory.length > 0) {
                    renderHistoryDropdown();
                    dropdown.classList.add('visible');
                }
            });

            // Hide dropdown on blur (with delay for click handling)
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    dropdown.classList.remove('visible');
                    historySelectedIndex = -1;
                }, 150);
            });

            // Keyboard navigation
            input.addEventListener('keydown', (e) => {
                if (!dropdown.classList.contains('visible')) return;

                const items = dropdown.querySelectorAll('.history-dropdown-item');
                if (items.length === 0) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    historySelectedIndex = Math.min(historySelectedIndex + 1, items.length - 1);
                    updateHistorySelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    historySelectedIndex = Math.max(historySelectedIndex - 1, -1);
                    updateHistorySelection(items);
                } else if (e.key === 'Enter' && historySelectedIndex >= 0) {
                    e.preventDefault();
                    const query = items[historySelectedIndex].dataset.query;
                    input.value = query;
                    dropdown.classList.remove('visible');
                    historySelectedIndex = -1;
                    runSearch();
                } else if (e.key === 'Escape') {
                    dropdown.classList.remove('visible');
                    historySelectedIndex = -1;
                }
            });

            // Hide on input (user is typing new query)
            input.addEventListener('input', () => {
                if (input.value.length > 0) {
                    dropdown.classList.remove('visible');
                } else if (state.searchHistory.length > 0) {
                    renderHistoryDropdown();
                    dropdown.classList.add('visible');
                }
            });
        }

        function updateHistorySelection(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('selected', idx === historySelectedIndex);
            });
        }

        function renderHistoryDropdown() {
            const dropdown = document.getElementById('history-dropdown');

            if (state.searchHistory.length === 0) {
                dropdown.innerHTML = '<div class="history-dropdown-empty">No recent searches</div>';
                return;
            }

            dropdown.innerHTML = state.searchHistory.map((query, idx) => `
                <div class="history-dropdown-item" data-query="${escapeHtml(query)}" data-index="${idx}">
                    <span>${escapeHtml(query)}</span>
                    <span class="delete-btn" data-index="${idx}">&times;</span>
                </div>
            `).join('');

            // Click to select
            dropdown.querySelectorAll('.history-dropdown-item').forEach(item => {
                item.addEventListener('mousedown', (e) => {
                    // Don't select if clicking delete button
                    if (e.target.classList.contains('delete-btn')) return;
                    e.preventDefault();
                    const query = item.dataset.query;
                    document.getElementById('query-input').value = query;
                    dropdown.classList.remove('visible');
                    runSearch();
                });
            });

            // Delete individual items
            dropdown.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    state.searchHistory.splice(idx, 1);
                    saveState();
                    renderHistoryDropdown();
                    if (state.searchHistory.length === 0) {
                        dropdown.classList.remove('visible');
                    }
                });
            });
        }

        function renderSearchHistory() {
            // Called after adding to history - dropdown will show on next focus
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ========================================
        // Explorer Inspector Functions
        // ========================================

        function selectResult(result) {
            // Update selected state
            state.selectedResult = result;

            // Visual feedback
            const cards = document.querySelectorAll('.result-row');
            cards.forEach(c => c.classList.remove('selected'));
            const selectedCard = document.querySelector(`[data-result-id="${result.relative_path}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }

            // Update inspector
            renderInspector(result);

            // Mobile: show inspector drawer
            if (window.innerWidth <= 768) {
                const inspectorPane = document.getElementById('inspector-pane');
                if (inspectorPane) {
                    inspectorPane.classList.add('visible');
                }
            }
        }

        function renderInspector(result) {
            const inspectorContent = document.querySelector('#inspector-pane .pane-content');
            if (!inspectorContent) return;

            const container = document.createElement('div');
            container.style.position = 'relative';

            // Close button (mobile only)
            const closeBtn = document.createElement('div');
            closeBtn.className = 'close-inspector';
            closeBtn.innerHTML = '√ó';
            closeBtn.addEventListener('click', () => {
                const inspectorPane = document.getElementById('inspector-pane');
                if (inspectorPane) {
                    inspectorPane.classList.remove('visible');
                }
                const cards = document.querySelectorAll('.result-row');
                cards.forEach(c => c.classList.remove('selected'));
                state.selectedResult = null;
            });
            container.appendChild(closeBtn);

            // Title section
            const titleSection = document.createElement('div');
            titleSection.className = 'inspector-section';

            const title = document.createElement('div');
            title.className = 'inspector-title';
            title.textContent = result.title || result.relative_path;
            titleSection.appendChild(title);

            const path = document.createElement('div');
            path.className = 'inspector-path';
            path.textContent = result.relative_path;
            titleSection.appendChild(path);

            const link = document.createElement('a');
            link.className = 'inspector-link';
            link.href = result.obsidian_uri;
            link.textContent = '‚Üó Open in Obsidian';
            titleSection.appendChild(link);

            container.appendChild(titleSection);

            // Similar by Topic section (semantic neighbors) - placed first
            const similarSection = document.createElement('div');
            similarSection.className = 'inspector-section';
            similarSection.id = 'similar-section';

            const similarTitle = document.createElement('h3');
            similarTitle.textContent = 'Similar by Topic';
            similarSection.appendChild(similarTitle);

            const similarContent = document.createElement('div');
            similarContent.id = 'similar-content';
            similarContent.innerHTML = '<span style="color: #888; font-size: 12px;">Loading...</span>';
            similarSection.appendChild(similarContent);

            container.appendChild(similarSection);

            // Graph section (linked notes)
            const graphSection = document.createElement('div');
            graphSection.className = 'inspector-section';
            graphSection.id = 'graph-section';

            const graphTitle = document.createElement('h3');
            graphTitle.textContent = 'Linked Notes';
            graphSection.appendChild(graphTitle);

            const graphContent = document.createElement('div');
            graphContent.id = 'graph-content';
            graphContent.innerHTML = '<span style="color: #888; font-size: 12px;">Loading graph...</span>';
            graphSection.appendChild(graphContent);

            container.appendChild(graphSection);

            // Scores section
            const scoresSection = document.createElement('div');
            scoresSection.className = 'inspector-section';

            const scoresTitle = document.createElement('h3');
            scoresTitle.textContent = 'Scores';
            scoresSection.appendChild(scoresTitle);

            // Semantic score
            if (result.similarity_score !== undefined) {
                scoresSection.appendChild(createScoreBar(
                    'Semantic',
                    result.similarity_score,
                    result.similarity_score,
                    '<strong>Scale: 0.0 to 1.0</strong><br>' +
                    'Measures conceptual similarity using AI embeddings. ' +
                    'Finds documents about the same topic even if they use different words.<br><br>' +
                    '<strong>0.0-0.3:</strong> Not relevant<br>' +
                    '<strong>0.3-0.5:</strong> Somewhat related<br>' +
                    '<strong>0.5-0.7:</strong> Relevant<br>' +
                    '<strong>0.7-1.0:</strong> Highly relevant'
                ));
            }

            // BM25 score (normalize to 0-1 for visual, assuming max ~10)
            if (result.bm25_score !== undefined) {
                const normalizedBM25 = Math.min(result.bm25_score / 10, 1);
                scoresSection.appendChild(createScoreBar(
                    'BM25',
                    result.bm25_score.toFixed(2),
                    normalizedBM25,
                    '<strong>Scale: 0 to 30+ (typical: 0-15)</strong><br>' +
                    'Keyword matching score. Higher = more exact word matches.<br><br>' +
                    '<strong>Factors:</strong><br>' +
                    '‚Ä¢ How often query words appear<br>' +
                    '‚Ä¢ How rare the words are (rare = higher)<br>' +
                    '‚Ä¢ Document length (longer = lower)<br>' +
                    '‚Ä¢ Tags get 2x weight + 5x boost when matched<br><br>' +
                    '<strong>0-5:</strong> Weak match<br>' +
                    '<strong>5-15:</strong> Good match<br>' +
                    '<strong>15+:</strong> Excellent match (often tag-boosted)'
                ));
            }

            // RRF score
            if (result.rrf_score !== undefined) {
                scoresSection.appendChild(createScoreBar(
                    'RRF',
                    result.rrf_score.toFixed(4),
                    result.rrf_score,
                    '<strong>Scale: 0.0 to ~0.05 (typical)</strong><br>' +
                    'Reciprocal Rank Fusion - combines Semantic + BM25 rankings.<br><br>' +
                    '<strong>How it works:</strong><br>' +
                    'RRF = sum(1 / (60 + rank))<br>' +
                    '‚Ä¢ Docs in both lists: highest scores<br>' +
                    '‚Ä¢ Tag-boosted docs: 1.5-2.0x multiplier<br>' +
                    '‚Ä¢ BM25-only docs: conservative boost<br><br>' +
                    '<strong>0.00-0.02:</strong> Lower ranked<br>' +
                    '<strong>0.02-0.04:</strong> Mid-tier<br>' +
                    '<strong>0.04+:</strong> Top results'
                ));
            }

            // Cross-encoder score
            if (result.cross_encoder_score !== undefined) {
                // Cross-encoder is typically -1 to 1, normalize to 0-1
                const normalized = (result.cross_encoder_score + 1) / 2;
                scoresSection.appendChild(createScoreBar(
                    'Cross-Enc',
                    result.cross_encoder_score.toFixed(4),
                    normalized,
                    '<strong>Scale: -12 to +12 (typical: -1 to +1)</strong><br>' +
                    'Precision re-ranking using ms-marco-MiniLM model. ' +
                    'Processes query + document together for accurate relevance.<br><br>' +
                    '<strong>Negative:</strong> Not relevant<br>' +
                    '<strong>-1 to 0:</strong> Weak match<br>' +
                    '<strong>0 to +2:</strong> Good match<br>' +
                    '<strong>+2 to +12:</strong> Excellent match<br><br>' +
                    '<em>Note: Skipped for tag-boosted results (already perfect)</em>'
                ));
            }

            // Tag boost indicator
            if (result.tag_boosted) {
                const row = document.createElement('div');
                row.className = 'inspector-row';
                const label = document.createElement('div');
                label.className = 'inspector-label';
                label.textContent = 'Tag Boosted';
                const value = document.createElement('div');
                value.className = 'inspector-value';

                // Show actual multiplier effect
                const currentMultiplier = state.liveParams.tag_multiplier;
                if (currentMultiplier > 1) {
                    value.textContent = `‚ö° Yes (${currentMultiplier}x)`;
                    value.style.color = '#cc8800';
                } else if (currentMultiplier === 1) {
                    value.textContent = '‚ö° Disabled (1x)';
                    value.style.color = '#888888';
                } else {
                    value.textContent = `‚ö° Reduced (${currentMultiplier}x)`;
                    value.style.color = '#666666';
                }

                row.appendChild(label);
                row.appendChild(value);
                scoresSection.appendChild(row);
            }

            // Time boost
            if (result.time_boost !== undefined && result.time_boost > 0) {
                const row = document.createElement('div');
                row.className = 'inspector-row';
                const label = document.createElement('div');
                label.className = 'inspector-label';
                label.textContent = 'Time Boost';
                const value = document.createElement('div');
                value.className = 'inspector-value';
                value.textContent = `+${(result.time_boost * 100).toFixed(0)}%`;
                value.style.color = '#88aa88';
                row.appendChild(label);
                row.appendChild(value);
                scoresSection.appendChild(row);
            }

            // Final score (if remixed)
            if (result.final_score !== undefined) {
                const results = state.remixedResults.length > 0 ? state.remixedResults : state.rawResults;
                const maxFinal = Math.max(...results.map(r => r.final_score || 0));
                const normalized = maxFinal > 0 ? result.final_score / maxFinal : 0;
                scoresSection.appendChild(createScoreBar(
                    'Final',
                    result.final_score.toFixed(4),
                    normalized,
                    '<strong>Scale: 0.0 to 2.0+ (depends on mix)</strong><br>' +
                    'Client-side remixed score using LIVE controls.<br><br>' +
                    '<strong>Formula:</strong><br>' +
                    'Final = (Sem √ó (1-balance) + BM25 √ó balance)<br>' +
                    '‚Ä¢ Tag-boosted: √ó Tag Multiplier<br>' +
                    '‚Ä¢ Recent docs: √ó (1 + Time Weight)<br><br>' +
                    '<em>Adjust sliders in Controls to see this change!</em>'
                ));
            }

            container.appendChild(scoresSection);

            // Metadata section
            if (result.frontmatter && Object.keys(result.frontmatter).length > 0) {
                const metaSection = document.createElement('div');
                metaSection.className = 'inspector-section';

                const metaTitle = document.createElement('h3');
                metaTitle.textContent = 'Metadata';
                metaSection.appendChild(metaTitle);

                // Dates
                if (result.frontmatter.created) {
                    metaSection.appendChild(createInspectorRow('Created', formatDate(result.frontmatter.created)));
                }
                if (result.frontmatter.modified) {
                    metaSection.appendChild(createInspectorRow('Modified', formatDate(result.frontmatter.modified)));
                }

                // Type
                if (result.frontmatter.type) {
                    const typeVal = Array.isArray(result.frontmatter.type)
                        ? result.frontmatter.type.join(', ')
                        : String(result.frontmatter.type);
                    metaSection.appendChild(createInspectorRow('Type', typeVal));
                }

                // Project
                if (result.frontmatter.project) {
                    let projectVal = result.frontmatter.project;
                    if (Array.isArray(projectVal)) projectVal = projectVal.join(', ');
                    metaSection.appendChild(createInspectorRow('Project', String(projectVal)));
                }

                // Status (for gleanings)
                if (result.frontmatter.status) {
                    metaSection.appendChild(createInspectorRow('Status', result.frontmatter.status));
                }

                // Source/URL (for gleanings)
                if (result.frontmatter.source) {
                    metaSection.appendChild(createInspectorRow('Source', result.frontmatter.source));
                }
                if (result.frontmatter.url) {
                    const row = document.createElement('div');
                    row.className = 'inspector-row';
                    const label = document.createElement('div');
                    label.className = 'inspector-label';
                    label.textContent = 'URL';
                    const value = document.createElement('a');
                    value.href = result.frontmatter.url;
                    value.target = '_blank';
                    value.className = 'inspector-value';
                    value.style.color = '#6a8aaa';
                    value.style.textDecoration = 'none';
                    value.textContent = truncateUrl(result.frontmatter.url);
                    row.appendChild(label);
                    row.appendChild(value);
                    metaSection.appendChild(row);
                }

                container.appendChild(metaSection);
            }

            // Tags section
            if (result.tags && result.tags.length > 0) {
                const tagsSection = document.createElement('div');
                tagsSection.className = 'inspector-section';

                const tagsTitle = document.createElement('h3');
                tagsTitle.textContent = `Tags (${result.tags.length})`;
                tagsSection.appendChild(tagsTitle);

                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'inspector-tags';
                result.tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'inspector-tag';
                    tagSpan.textContent = `#${tag}`;
                    tagsContainer.appendChild(tagSpan);
                });
                tagsSection.appendChild(tagsContainer);

                container.appendChild(tagsSection);
            }

            // Description section
            if (result.description) {
                const descSection = document.createElement('div');
                descSection.className = 'inspector-section';

                const descTitle = document.createElement('h3');
                descTitle.textContent = 'Description';
                descSection.appendChild(descTitle);

                const descText = document.createElement('div');
                descText.style.fontSize = '12px';
                descText.style.color = '#b0b0b0';
                descText.style.lineHeight = '1.5';
                descText.textContent = result.description;
                descSection.appendChild(descText);

                container.appendChild(descSection);
            }

            // Add to DOM first, THEN fetch graph data
            inspectorContent.replaceChildren(container);

            // Fetch graph data asynchronously (after DOM is ready)
            fetchGraphNeighbors(result.relative_path);

            // Fetch semantic neighbors asynchronously
            fetchSemanticNeighbors(result);
        }

        async function fetchGraphNeighbors(relativePath) {
            const graphContent = document.getElementById('graph-content');
            if (!graphContent) {
                return;
            }

            try {
                // Extract note name from path (remove extension and directory)
                const noteName = relativePath
                    .replace(/\.md$/, '')
                    .split('/')
                    .pop();

                // Show what we're looking for
                graphContent.innerHTML = `<span style="color: #888; font-size: 11px;">Looking up: ${noteName}...</span>`;

                const params = new URLSearchParams({
                    note: noteName,
                    vault: state.vault || '',
                    hops: 2
                });

                const response = await fetch(`/graph/neighbors?${params}`);
                const data = await response.json();

                if (!data.found) {
                    graphContent.innerHTML = '<span style="color: #666; font-size: 12px;">No links found (isolated note)</span>';
                    return;
                }

                // Build the display
                const container = document.createElement('div');

                // Incoming links (notes that link TO this note)
                if (data.incoming && data.incoming.length > 0) {
                    const inSection = document.createElement('div');
                    inSection.style.marginBottom = '12px';

                    const inTitle = document.createElement('div');
                    inTitle.style.fontSize = '11px';
                    inTitle.style.color = '#888';
                    inTitle.style.marginBottom = '4px';
                    inTitle.textContent = `‚Üê Links here (${data.incoming.length})`;
                    inSection.appendChild(inTitle);

                    const inLinks = document.createElement('div');
                    inLinks.style.display = 'flex';
                    inLinks.style.flexWrap = 'wrap';
                    inLinks.style.gap = '4px';

                    // Show first 10, with expandable
                    const showIncoming = data.incoming.slice(0, 10);
                    showIncoming.forEach(note => {
                        const link = createGraphLink(note, 'incoming');
                        inLinks.appendChild(link);
                    });

                    if (data.incoming.length > 10) {
                        const more = document.createElement('span');
                        more.style.fontSize = '11px';
                        more.style.color = '#666';
                        more.style.padding = '2px 6px';
                        more.textContent = `+${data.incoming.length - 10} more`;
                        inLinks.appendChild(more);
                    }

                    inSection.appendChild(inLinks);
                    container.appendChild(inSection);
                }

                // Outgoing links (notes this note links TO)
                if (data.outgoing && data.outgoing.length > 0) {
                    const outSection = document.createElement('div');
                    outSection.style.marginBottom = '12px';

                    const outTitle = document.createElement('div');
                    outTitle.style.fontSize = '11px';
                    outTitle.style.color = '#888';
                    outTitle.style.marginBottom = '4px';
                    outTitle.textContent = `‚Üí Links to (${data.outgoing.length})`;
                    outSection.appendChild(outTitle);

                    const outLinks = document.createElement('div');
                    outLinks.style.display = 'flex';
                    outLinks.style.flexWrap = 'wrap';
                    outLinks.style.gap = '4px';

                    const showOutgoing = data.outgoing.slice(0, 10);
                    showOutgoing.forEach(note => {
                        const link = createGraphLink(note, 'outgoing');
                        outLinks.appendChild(link);
                    });

                    if (data.outgoing.length > 10) {
                        const more = document.createElement('span');
                        more.style.fontSize = '11px';
                        more.style.color = '#666';
                        more.style.padding = '2px 6px';
                        more.textContent = `+${data.outgoing.length - 10} more`;
                        outLinks.appendChild(more);
                    }

                    outSection.appendChild(outLinks);
                    container.appendChild(outSection);
                }

                // 2-hop neighbors (if any beyond direct links)
                const twoHop = data.by_distance && data.by_distance['2'];
                if (twoHop && twoHop.length > 0) {
                    const hopSection = document.createElement('div');

                    const hopTitle = document.createElement('div');
                    hopTitle.style.fontSize = '11px';
                    hopTitle.style.color = '#888';
                    hopTitle.style.marginBottom = '4px';
                    hopTitle.textContent = `2 hops away (${twoHop.length})`;
                    hopSection.appendChild(hopTitle);

                    const hopLinks = document.createElement('div');
                    hopLinks.style.display = 'flex';
                    hopLinks.style.flexWrap = 'wrap';
                    hopLinks.style.gap = '4px';

                    // Filter out daily notes for cleaner display, show first 8
                    const nonDaily = twoHop.filter(n =>
                        !n.match(/^\d{4}-\d{2}-\d{2}/) &&
                        !n.startsWith('Daily/')
                    );
                    const show2Hop = nonDaily.slice(0, 8);

                    if (show2Hop.length > 0) {
                        show2Hop.forEach(note => {
                            const link = createGraphLink(note, 'distant');
                            hopLinks.appendChild(link);
                        });

                        if (nonDaily.length > 8) {
                            const more = document.createElement('span');
                            more.style.fontSize = '11px';
                            more.style.color = '#666';
                            more.style.padding = '2px 6px';
                            more.textContent = `+${nonDaily.length - 8} more`;
                            hopLinks.appendChild(more);
                        }

                        hopSection.appendChild(hopLinks);
                        container.appendChild(hopSection);
                    }
                }

                // No links at all
                if (container.children.length === 0) {
                    container.innerHTML = '<span style="color: #666; font-size: 12px;">No links found</span>';
                }

                graphContent.replaceChildren(container);

            } catch (err) {
                graphContent.innerHTML = `<span style="color: #c66; font-size: 11px;">Error: ${err.message}</span>`;
            }
        }

        async function fetchSemanticNeighbors(result) {
            const similarContent = document.getElementById('similar-content');
            if (!similarContent) {
                return;
            }

            try {
                // Use the note's title as the search query
                const title = result.title || result.relative_path.replace(/\.md$/, '').split('/').pop();

                const params = new URLSearchParams({
                    q: title,
                    vault: state.vault || '',
                    limit: 8,
                    hybrid_weight: 1.0,  // Pure semantic search
                    rerank: false,
                    expand: false
                });

                const response = await fetch(`/search?${params}`);
                const data = await response.json();

                if (!data.results || data.results.length === 0) {
                    similarContent.innerHTML = '<span style="color: #666; font-size: 12px;">No similar notes found</span>';
                    return;
                }

                // Filter out the current note and take top results
                const currentPath = result.relative_path;
                const neighbors = data.results
                    .filter(r => r.relative_path !== currentPath)
                    .slice(0, 6);

                if (neighbors.length === 0) {
                    similarContent.innerHTML = '<span style="color: #666; font-size: 12px;">No similar notes found</span>';
                    return;
                }

                // Build the display
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexWrap = 'wrap';
                container.style.gap = '4px';

                neighbors.forEach(neighbor => {
                    const chip = createSimilarChip(neighbor);
                    container.appendChild(chip);
                });

                similarContent.replaceChildren(container);

            } catch (err) {
                similarContent.innerHTML = `<span style="color: #c66; font-size: 11px;">Error: ${err.message}</span>`;
            }
        }

        function createSimilarChip(result) {
            const chip = document.createElement('span');
            chip.style.fontSize = '11px';
            chip.style.padding = '2px 6px';
            chip.style.borderRadius = '3px';
            chip.style.cursor = 'pointer';
            chip.style.maxWidth = '150px';
            chip.style.overflow = 'hidden';
            chip.style.textOverflow = 'ellipsis';
            chip.style.whiteSpace = 'nowrap';
            chip.style.display = 'inline-block';
            chip.style.background = 'rgba(200, 150, 100, 0.2)';
            chip.style.color = '#d8a87c';

            const title = result.title || result.relative_path.replace(/\.md$/, '').split('/').pop();
            chip.title = `${title} (${(result.similarity_score * 100).toFixed(0)}% similar)`;

            // Truncate long names
            const displayName = title.length > 25
                ? title.substring(0, 22) + '...'
                : title;
            chip.textContent = displayName;

            // Click to open in Obsidian
            chip.addEventListener('click', (e) => {
                e.stopPropagation();
                if (result.obsidian_uri) {
                    window.open(result.obsidian_uri, '_blank');
                }
            });

            return chip;
        }

        function createGraphLink(noteName, type) {
            const link = document.createElement('span');
            link.style.fontSize = '11px';
            link.style.padding = '2px 6px';
            link.style.borderRadius = '3px';
            link.style.cursor = 'pointer';
            link.style.maxWidth = '150px';
            link.style.overflow = 'hidden';
            link.style.textOverflow = 'ellipsis';
            link.style.whiteSpace = 'nowrap';
            link.style.display = 'inline-block';
            link.title = noteName;

            // Color by type
            if (type === 'incoming') {
                link.style.background = 'rgba(100, 150, 200, 0.2)';
                link.style.color = '#8ab4d8';
            } else if (type === 'outgoing') {
                link.style.background = 'rgba(150, 200, 100, 0.2)';
                link.style.color = '#a8d080';
            } else {
                link.style.background = 'rgba(150, 150, 150, 0.15)';
                link.style.color = '#999';
            }

            // Truncate long names
            const displayName = noteName.length > 25
                ? noteName.substring(0, 22) + '...'
                : noteName;
            link.textContent = displayName;

            // Click to open in Obsidian
            link.addEventListener('click', (e) => {
                e.stopPropagation();
                // Get vault name from selected result's obsidian_uri
                if (state.selectedResult?.obsidian_uri) {
                    const vaultName = state.selectedResult.obsidian_uri.split('/')[3];
                    const noteUri = `obsidian://vault/${vaultName}/${encodeURIComponent(noteName)}`;
                    window.open(noteUri, '_blank');
                }
            });

            return link;
        }

        function createScoreBar(label, displayValue, normalizedValue, tooltip = null) {
            const row = document.createElement('div');
            row.className = 'inspector-row';
            row.style.borderBottom = 'none';
            row.style.marginBottom = '6px';

            const labelDiv = document.createElement('div');
            labelDiv.className = 'inspector-label';
            labelDiv.style.display = 'flex';
            labelDiv.style.alignItems = 'center';
            labelDiv.style.gap = '4px';

            const labelText = document.createElement('span');
            labelText.textContent = label;
            labelDiv.appendChild(labelText);

            // Add tooltip if provided
            if (tooltip) {
                const tooltipWrapper = document.createElement('span');
                tooltipWrapper.className = 'tooltip-wrapper';
                tooltipWrapper.style.display = 'inline-block';

                const infoIcon = document.createElement('span');
                infoIcon.className = 'info-icon';
                infoIcon.textContent = '?';
                infoIcon.style.fontSize = '10px';
                infoIcon.style.cursor = 'help';

                const tooltipSpan = document.createElement('span');
                tooltipSpan.className = 'tooltip';
                tooltipSpan.innerHTML = tooltip;

                tooltipWrapper.appendChild(infoIcon);
                tooltipWrapper.appendChild(tooltipSpan);
                labelDiv.appendChild(tooltipWrapper);
            }

            const barContainer = document.createElement('div');
            barContainer.className = 'score-bar';
            barContainer.style.flex = '1';

            const valueDiv = document.createElement('div');
            valueDiv.className = 'score-value';
            valueDiv.textContent = typeof displayValue === 'number' ? displayValue.toFixed(3) : displayValue;

            const visualDiv = document.createElement('div');
            visualDiv.className = 'score-visual';

            const fillDiv = document.createElement('div');
            fillDiv.className = 'score-fill';
            fillDiv.style.width = `${Math.max(0, Math.min(100, normalizedValue * 100))}%`;

            visualDiv.appendChild(fillDiv);
            barContainer.appendChild(valueDiv);
            barContainer.appendChild(visualDiv);

            row.appendChild(labelDiv);
            row.appendChild(barContainer);

            return row;
        }

        function createInspectorRow(label, value) {
            const row = document.createElement('div');
            row.className = 'inspector-row';

            const labelDiv = document.createElement('div');
            labelDiv.className = 'inspector-label';
            labelDiv.textContent = label;

            const valueDiv = document.createElement('div');
            valueDiv.className = 'inspector-value mono';
            valueDiv.textContent = value;

            row.appendChild(labelDiv);
            row.appendChild(valueDiv);

            return row;
        }

        function truncateUrl(url, maxLen = 40) {
            if (!url || url.length <= maxLen) return url;
            return url.substring(0, maxLen - 3) + '...';
        }

        function formatDate(dateStr) {
            if (!dateStr) return null;
            try {
                const date = new Date(dateStr);
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch {
                return dateStr;
            }
        }

        // ========================================
        // Tooltip Positioning
        // ========================================

        // Smart tooltip positioning to prevent clipping
        document.addEventListener('mouseover', (e) => {
            const tooltipWrapper = e.target.closest('.tooltip-wrapper');
            if (!tooltipWrapper) return;

            const tooltip = tooltipWrapper.querySelector('.tooltip');
            if (!tooltip) return;

            const rect = tooltipWrapper.getBoundingClientRect();
            const tooltipWidth = 240; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 200; // Estimate if not rendered

            // Position below the icon by default
            let top = rect.bottom + 8;
            let left = rect.left;

            // If tooltip would go off right edge, align to right
            if (left + tooltipWidth > window.innerWidth - 10) {
                left = rect.right - tooltipWidth;
            }

            // If tooltip would go off bottom, show above instead
            if (top + tooltipHeight > window.innerHeight - 10) {
                top = rect.top - tooltipHeight - 8;
            }

            // Prevent going off left edge
            if (left < 10) {
                left = 10;
            }

            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
        });

        // Start the app
        initialize();
    </script>
</body>
</html>
